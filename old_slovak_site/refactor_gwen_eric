# this was the most common way that people did this, using a hash to keep track of the arabic #s and their decimal equivalents. Mine is a bit different and somehow both jankier and fewer lines of code than most.
def convert_to_roman(arabic_number)
roman_hash = {
10 => "X",
5 => "V",
1 => "I"
}
# using the modulos(doing, but repeating.)
output_string = String.new # going to iterate through the hash and add to the output string
roman_hash.each do |hasharabic, hashroman|
  output_string += hashroman * (arabic_number / hasharabic) # add to the output ("X" * # number of times the original input number is dividble by 10.) 
  arabic_number = arabic_number % hasharabic # reassign the original number to the remainder of original number / 10. 
end
# if the number was 42, 42 is divisible by 10 four times, (4 Xs get added to output string) w/ remainer 2. 2 is divisible by 5 zero times (O * string adds nothing) w/ remainder 2, 2 is divisible by 1 two times (2 Is get added)
#You start from the top b/c the collections of the smaller nums are represented by the bigger nums (eg 10 * I = X ), so you want to knock down the bigger numbers first and put them in the front.
output_string
end 

puts 1
p convert_to_roman(1) 
puts 2
p convert_to_roman(2) 
puts 4
p convert_to_roman(4) 
puts 5
p convert_to_roman(5) 
puts 6
p convert_to_roman(6) 
puts 9
p convert_to_roman(9)
puts 10
p convert_to_roman(10)
puts 11
p convert_to_roman(11) 
puts 42
p convert_to_roman(42) 
puts 49
p convert_to_roman(49)
puts 75
p convert_to_roman(75)